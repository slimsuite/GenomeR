---
title: "Genomer report"
author: "Genomer"
output:
    pdf_document:
params:
    df : NA
    min_kmer : 0
    max_kmer : NA
    diploid: NA
    show_hide : "hide_error"
    

---



```{r echo=FALSE}

#library(knitr)
#read_chunk("simpleCountKmer.R")

 if (is.null(params$show_hide) || params$show_hide == "hide_error") {
    show = FALSE
} else if (params$show_hide == "show_error") {
    show = TRUE
}
```

### Genomer Summmary

stuff.....
......
.......
......
```{r cars}

```

### Simple Count Summary
Simple count calculates the size of the genome by counting the number of unique kmer frequencies

``` {r simpleCount, echo=FALSE}
simple_count_kmer <- function(df, start_freq = NULL, end_freq = NULL, show_error = TRUE) {
    # df = read.table(filename)
    # names(df) = c("Frequency", "Count")
    
    # freq and count max values
    max_count = max(df$Count)
    max_freq = max(df$Frequency)
    
    # determine start and end
    if (is.null(start_freq)) {
        start_freq = calc_start_freq(df)
    } else if (start_freq < 0) {
        start_freq = 0
    }
    
    if (is.null(end_freq) || end_freq > max_freq) {
        end_freq = max_freq
    }
    
    if (end_freq < 0) {
        end_freq = max_freq + end_freq
    }
    
    # get rows within freq range
    rows = df[df$Frequency >= start_freq & df$Frequency <= end_freq,]

    # ggplot version
    # graph = ggplot(df[start_freq:end_freq,], aes(x = Frequency, y = Count)) + geom_line()
    
    # plotly version
    # plot rectangles over ignored regions
    plot_data = rows       # plot only counted region
    rectangles = NULL
    if (show_error) {
        plot_data = df
        rectangles = list(
            # error rectangle low frequency end
            list(type = "rect",
                 fillcolor = "red", line = list(color = "red"), opacity = 0.3,
                 x0 = 0, x1 = start_freq, xref = "Frequency",
                 y0 = 0, y1 = max_count, yref = "Count"
            ),
            
            # error rectangle high frequency end
            list(type = "rect",
                 fillcolor = "red", line = list(color = "red"), opacity = 0.3,
                 x0 = end_freq, x1 = max_freq, xref = "Frequency",
                 y0 = 0, y1 = max_count, yref = "Count"
            )
        )
    }
    
    # plot with shapes
    p = plot_ly(plot_data, x= ~Frequency, y= ~Count, name = "Count", type="bar")
    p = layout(p, bargap = 0.01, bargroupgap = 0.01, shapes = rectangles)
    
    # calculate size using simple unique kmer counting
    size = sum(as.numeric(rows$Count))
    total_kmers = as.integer(sum(as.numeric(df$Frequency)))
    error = total_kmers - size
    
    return (list("graph" = p, "size" = size, "total_kmers" = total_kmers, "error" = error))
}

simple_count = simple_count_kmer(params$df, params$min_kmer, params$max_kmer, show_error = show)


```
#### Size Estimate: 

`r simple_count$size/1000000` MB

#### Frequency vs Count Graph

``` {r simple_graph, echo=FALSE }
simple_count$graph

```

### Peak Frequency Summary
Peak Frequency calculates genome size by finding the frequency with the highest count
```{r peakFrequency, echo=FALSE}
peak_count_kmer <- function(df, start_freq = NULL, end_freq = NULL, show_error = TRUE, num_peaks = 1) {
    library(quantmod)
    
    # initial max_freq
    max_count = max(df$Count)
    max_freq = max(df$Frequency)
    
    # determine start and end
    if (is.null(start_freq)) {
        start_freq = calc_start_freq(df)
    } else if (start_freq < 0) {
        start_freq = 0
    }
    
    if (is.null(end_freq) || end_freq > max_freq) {
        end_freq = max_freq
    } else if (end_freq < 0) {
        end_freq = max_freq + end_freq
    }
    
    # get rows within freq range
    rows = df[df$Frequency >= start_freq & df$Frequency <= end_freq,]
    
    # freq and count max values recalculated using cutoffs
    if (!show_error) {
        max_count = max(rows$Count)
        max_freq = max(rows$Count)
    }
    
    # plotly version
    # plot rectangles over ignored regions
    plot_data = rows       # plot only counted region
    rectangles = NULL
    if (show_error) {
        plot_data = df
        rectangles = list(
            # error rectangle low frequency end
            list(type = "rect",
                 fillcolor = "red", line = list(color = "red"), opacity = 0.3,
                 x0 = 0, x1 = start_freq, xref = "Frequency",
                 y0 = 0, y1 = max_count, yref = "Count"
            ),
            
            # error rectangle high frequency end
            list(type = "rect",
                 fillcolor = "red", line = list(color = "red"), opacity = 0.3,
                 x0 = end_freq, x1 = max_freq, xref = "Frequency",
                 y0 = 0, y1 = max_count, yref = "Count"
            )
        )
    }
    
    # get peak_rows
    peak_rows = findPeaks(plot_data$Count)-1
    
    # print(peak_rows)
    # print(length(peak_rows))
    # print(num_peaks)
    if (num_peaks > length(peak_rows)) {
        num_peaks = length(peak_rows)
    }
    peak_rows = peak_rows[1:num_peaks]
    # print(peak_rows)
    
    # traces
    Peaks = plot_data[peak_rows,]        # get peak Freq and Count
    Peaks = Peaks[order(-Peaks$Count),]  # order on Count
    # print(Peaks)
    
    # get peak of plot
    peak_freq = Peaks$Frequency[1]
    
    # peak lines
    # initiate a line shape object
    line <- list(
        type = "line",
        line = list(color = "orange", dash = "dash"),
        xref = "Frequency",
        yref = "Count"
    )
    
    lines <- list()
    for (i in rownames(Peaks)) {
        peak = Peaks[i,]
        line[c("x0", "x1")] <- peak$Frequency
        line[["y0"]] <- 0
        line[["y1"]] <- max_count
        lines <- c(lines, list(line))
    }
    
    # combine all shapes
    shapes = append(rectangles, lines)
    
    # create plot
    Frequency = plot_data$Frequency
    Count = plot_data$Count
    p = plot_ly(plot_data, x= ~Frequency, y= ~Count,
                name = "Count", type="scatter", mode="lines")
    p = add_trace(p, x= ~Peaks$Frequency, y = ~Peaks$Count,
                  name = "Peaks", mode = "markers")
    p = layout(p, showlegend = FALSE, shapes = shapes)
    p$elementId = NULL  #TODO temp approach to suppress warning
    
    # calculate size using simple unique kmer counting
    # only use non-error rows
    
    size = as.integer(sum(as.numeric(rows$Frequency * rows$Count)) / peak_freq)
    total_kmers = as.integer(sum(as.numeric(df$Frequency)))
    if (num_peaks == 2) {
        
        #find the peak with highest frequency
        if(Peaks$Frequency[1] > Peaks$Frequency[2]) {
            highest_freq = Peaks$Frequency[1]
            lower_freq = Peaks$Frequency[2]
        } else {
            highest_freq = Peaks$Frequency[2]
            lower_freq = Peaks$Frequency[1]
        }
        
        highest_freq_count = rows$Count[rows$Frequency == highest_freq] 
        lower_freq_count = rows$Count[rows$Frequency == lower_freq]
        
        #find the frequency with the highest count
        if(highest_freq_count > lower_freq_count) {
            smaller_count = lower_freq_count
        } else {
            smaller_count = highest_freq_count
        }
        
        #print(smaller_count/(highest_freq_count + lower_freq_count))
        
        #does not do diploid calculateion if ratio of highest
        #and lowest frequency count is less that arbitrary 0.001
        #if((smaller_count/(highest_freq_count + lower_freq_count)) < 0.001) {
            
            #valley between peaks
            between_rows = rows[rows$Frequency < highest_freq & rows$Frequency > lower_freq,]
            #print(between_rows)
            valley_rows = findValleys(between_rows$Count)
            valley_freq = between_rows$Frequency[valley_rows]
            
            #get size of hetrozygous part and divide by 2
            hetro_rows = rows[rows$Frequency < valley_freq,]
            hetro_size = as.integer(sum(as.numeric(hetro_rows$Frequency * hetro_rows$Count))/(2*highest_freq))
            
            #get size of rest of genome
            homo_rows = rows[rows$Frequency >= valley_freq,]
            homo_size = as.integer(sum(as.numeric(homo_rows$Frequency * homo_rows$Count))/highest_freq)
            
            size = (homo_size + hetro_size)
            
       # }
        
        
    }
    error = total_kmers - size
    
    
    
    return (list("graph" = p, "size" = size, "total_kmers" = total_kmers, "error" = error))
}

calc_start_freq <- function(df) {
    library(quantmod)
    # if start_freq not set we set the error
    valley_rows = findValleys(df$Count)-1
    start_freq = df$Frequency[valley_rows[1]]
    return(start_freq)
}

if(params$diploid == "diploid") {
    num_peaks = 2
} else {
    num_peaks = 1
}

peak_count = peak_count_kmer(params$df, params$min_kmer, params$max_kmer, show_error = show, num_peaks)
```

#### Size Estimate:
`r peak_count$size/1000000` MB

#### Frequency vs Count Graph
```{r peak_graph, echo=FALSE}
peak_count$graph
```


